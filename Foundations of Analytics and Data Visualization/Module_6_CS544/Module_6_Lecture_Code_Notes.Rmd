# Module 6 Lecture Notes


#####################################
### Section #1: Strings and REGEX ###
#####################################

# R provides very basic support for manipulating strings, both for data preparation and data cleaning. String manipulation is quite often needed for text processing and analyzing data which has string attributes. The stringr package provides more robust support for most commonly used string operations. The stringr package can be installed through the RStudio menu options, or programmatically with the following statement, if it was not already installed before.

if (!is.element("stringr", installed.packages()[, "Package"]))
    install.packages("stringr", repos="http://cran.us.r-project.org", dependencies = T)

library(stringr)

################################
### Common String Operations ###
################################

# The following sections describe some of the commonly used string operations provided by the stringr package.

#################
# Joining Strings
#################

# The str_c function is used for joining multiple strings into a single string. If the function is provided a single vector, the function returns a vector of the same length with every value converted to a string (character base type).

str_c(c(1,2))

# If the str_c function has multiple arguments, the corresponding elements from each vector are joined together and returned as a vector as shown below.

str_c(c("a", "b"), c(1, 2), c("c", "d"))

# The default separator is the empty string when the corresponding values are joined. An explicit value for the separator can also be specified as shown below. In that case, the corresponding values are joined together, separated by the specified value.

str_c(c("a", "b"), c(1, 2), c("c", "d"), sep = "-")

# Similar to other vector operations, when the corresponding lengths are not the same, the values in the shorter vectors are repeated to accommodate the corresponding values in the longer vector(s), as shown in the following two examples.

str_c(LETTERS, " is for", "...")

str_c(LETTERS, c(" is for", " for"), "...")

# The vector letters[-26] provides the vector of letters from a through y, whereas the vector letters[-1] provides the vector of letters from b through z. Joining the corresponding values with the string is before in between results in the following pattern:

str_c(letters[-26], " is before ", letters[-1])

# The input vectors can be collapsed into a single string using the collapse argument. The following examples show the results with a single vector, multiple vectors, and with both the sep and collapse values.

str_c(c(1,2), collapse = "")

str_c(c("a", "b"), c(1, 2), c("c", "d"), collapse = ":")

str_c(c("a", "b"), c(1, 2), c("c", "d"), sep = "-", collapse = ":")

# The vector of letters can be collapsed into a single string as shown in the following two examples.

str_c(letters, collapse = "")

str_c(letters, collapse = ":")

# The str_flatten takes a single argument and flattens it to a single string. The default collapse value is the empty string.

str_flatten(letters)

str_flatten(letters, collapse = ":")

####################
# Lengths of Strings
####################

# The str_length function returns the length of the input values, coerced as strings if needed, in the given vector.

str_length(c("a", "b", "c"))

str_length(c("a1", "b23", "c456"))

# The length of a missing value is reported as missing length.

str_length(c("a1", NA, "c456"))

#######################
# Substrings of Strings
#######################

# The str_sub function extracts substrings from the given input string vector. The start and end values may optionally specify the portion of the string to be extracted. The default value for start is 1, the beginning index of the string. The default value for end is -1, the last index of the string. The following example shows extracting the first 6 characters of the specified string.

s <- "United States"

str_length(s)

str_sub(s, 1, 6)

str_sub(s, end = 6)

str_sub(s, start = 2, end = 5)

# The following example shows two different ways of extracting the second word, States, from the given string. In the second case, the default end value -1 is used for the end of the string.

str_sub(s, 8, 13)

str_sub(s, 8)

# If a vector of values is specified for the beginning and end positions, a resulting vector of the substrings is produced. The start argument provides the two beginning indices and the end argument provides the two ending indices. As a result, two substrings are extracted with the corresponding start and end values from each vector.

str_sub(s, c(1, 8), c(6, 13))

str_sub(s, start = c(1, 8), end = c(6, 13))

# In the following example, the default end index of -1 is used for both the substrings.

str_sub(s, c(1, 8))

# In the following example, the default start index of 1 is used for both the substrings.

str_sub(s, end = c(6, 13))

# A negative value for any index is interpreted as the position counting backwards from the end of the string, -1 being the last index. The following examples provide the start index value as a negative value. The default end index, -1, is used.

str_sub(s, -1)

str_sub(s, -6)

# The following example shows the resulting string, ted, when both the beginning and ending indices are provided with negative values.

str_sub(s, -10, -8)

# The following example assumes the default start index of 1.

str_sub(s, end = -6)

# The str_sub function may also be used for replacing substrings from the given character vector. The following example shows the replacement of the first character in the given string, resulting in changing the given string from CLAP to FLAP.

x <- "CLAP"

str_sub(x, 1, 1) <- "F"; x

# The following examples show the replacement of the last character, changing the current string from FLAP to FLAT, and then a second replacement that changes the string from FLAT to FOOT. In the latter case, the target substring being replaced starts at index 2 and ends at index -2.

str_sub(x, -1, -1) <- "T"; x

str_sub(x, 2, -2) <- "OO"; x

# The following example only retains the first and last character of the given string, replacing everything else in between with the empty string.

str_sub(x, 2, -2) <- ""; x

########################
# Duplication of Strings
########################

# The str_dup function allows for duplication of strings to be duplicated the specified number of times. In the simplest case, with a single value of 2 for the times to duplicate, each string in the input vector is duplicated twice, as shown below.

x <- c("a1", "b2", "c3")

str_dup(x, 2)

# If the times to duplicate is a vector of values, the corresponding string in the input vector is duplicated the respective number of times, as shown below.

str_dup(x, 1:3)

# The following example concatenates the string a in front of each of the duplicated ha strings.

str_c("a", str_dup("ha", 0:4))

#####################
# Trimming of Strings
#####################

# The str_trim function removes white spaces from the ends of the input strings. The default behavior of the function is to remove both from the left and the right, if there are any.

x <- "          How            are      \n    you?\t"
x

str_trim(x)

str_trim(x, side = "left")

str_trim(x, side = "right")

# The str_squish function removes the white spaces from the ends of the string and also collapses consecutive white space character into a single space within the string.

x <- "      How       are     \n   you?\t"
str_squish(x)

x <- "\t How\t\t   \t\tare\tyou"
str_squish(x)

####################################
# Padding and Truncation of Strings
####################################

# The str_pad function may be used to pad the given strings to the given width. The default padding character is the space and padded on the left when the side is not specified explicitly. In the following example, the length of the resulting string will be 10 with 5 spaces padded on the left.

str_pad("cs544", 10)

str_pad("cs544", 10, pad = "_")

# The operations are vectorized when multiple strings and/or padding characters are specified as shown below.

str_pad(c("a", "abc", "abcdef"), 5)

str_pad("a", c(2, 4, 6))

str_pad("cs544", 10, pad = c("_", "#"))

str_pad(c("cs544", "cs555"), 10, pad = c("_", "#"))

# If the size is less than the length of the input string, the string is left unchanged.

str_pad("cs544", 3)

# The str_trunc function is used for truncating the given string. The default string that replaces the truncated content on the specified side is the ellipsis ...

x <- "Foundations of Data Analytics with R";x

str_length(x)

rbind(str_trunc(x, 25, "left"),
str_trunc(x, 25, "right"),
str_trunc(x, 25, "center"))

###############################
# Detecting Patterns in Strings
###############################

# The str_detect function is useful for detecting if the specified pattern is present or not in the given input string. The fruit dataset is a vector of 80 fruit names available with the stringr library.

head(fruit)

tail(fruit)

length(fruit)

# The str_detect function returns TRUE or FALSE for each presence or absence of the pattern. The logical results can then be indexed to select the detected values. The following example shows all the fruits which have the pattern ap in them.

fruit[str_detect(fruit, "ap")]

# The regular expression pattern ^ap specifies that the matched value should begin with the value ap. The result is the two fruits that match as shown below.

fruit[str_detect(fruit, "^ap")]

# The pattern it$ can be used to match all the fruits that end with the specified value it. This results in the 8 fruits that end with it as shown below.

fruit[str_detect(fruit, "it$")]

# The following example shows all fruits that either have a d or a v or a w in them.

fruit[str_detect(fruit, "[dvw]")]

# The following example shows all fruits that have a white space in them.

fruit[str_detect(fruit, "[:space:]")]

##############################
# Matching Patterns in Strings
##############################

# Pattern matching is an important step in text data processing. Typical searches involve looking for patterns in the data and finding those patterns. For the following samples, the data shown with 4 strings are used for illustrating the pattern matching functions.

data <- c("123 Main St", "6175551234", "978-356-1234", "Work: 617-423-4567; Home: 508.555.3589; Cell: 555 777 3456")

# The goal in this example is to look for phone numbers in the input strings. The phone numbers can be found with varying formats as in the example above. A regular expression can be used to capture these varying patterns. The following regular expression states that the phone number starts with a digit (2 to 9), followed by two digits (0 to 9), followed by an optional hyphen, space, or a period, followed by three digits (0 to 9), followed by an optional hyphen, space, or a period, and then four digits (0 to 9).

phone <- "([2-9][0-9]{2})([- .]?)([0-9]{3})([- .])?([0-9]{4})"

# The str_detect function can be used to check if the string has the pattern or not as shown below.

str_detect(data, phone)

# The above result can be used as a logical index into the data to display the matched inputs.

data[str_detect(data, phone)]

# The str_subset function can also be used to directly return the matched strings as shown below.

str_subset(data, phone)

# The str_locate function is useful for locating the positions of the pattern in the given string. The start and end indices of only the first match in the input strings are returned as a matrix.

str_locate(data, phone)

# The str_extract function can be used for extracting the first matched pattern in the input strings as shown below.

str_extract(data, phone)

# For locating all occurrences of the pattern in the input strings, the str_locate_all function returns a list of matrices as shown below. The last input string in the data has three matches.

str_locate_all(data, phone)

# The str_extract_all function can be used for extracting all the matched patterns as shown below. The result is a list of character vectors.

str_extract_all(data, phone)

# With the simplify option, the same function returns all matches as a matrix as shown below. The number of columns will correspond to the maximum number of matches in any of the input data.

str_extract_all(data, phone, simplify = T)

# The above functions were useful for extracting the matched pattern. The regular expression used for the phone numbers has the round brackets or parenthesis which can be used to identify the corresponding part of the matched pattern. The pattern in the example has five such groups underlined as shown below.

phone <- "([2-9][0-9]{2})([- .]?)([0-9]{3})([- .])?([0-9]{4})"

# The str_match function returns a matrix with the matched groups for the first match in the input strings. The first column shows the match and the next five columns show the corresponding group of the pattern.

str_match(data, phone)

# The str_match_all returns a list of matrices showing all the matches in the input strings as shown below.

str_match_all(data, phone)

# When publishing data, some of the information is redacted for public use. In such cases, the str_replace can be used as in the following example to replace the first matched phone number in each input string with the specified string.

str_replace(data, phone, "XXX-XXX-XXXX")

# All the matched patterns in each string can be replaced with the help of the str_replace_all function as shown below.

str_replace_all(data, phone, "XXX-XXX-XXXX")

# The str_remove and str_remove_all are wrappers for the str_replace and str_replace_all functions and can also be used in their place instead.

#############################
# Counting Matches in Strings
#############################

# The str_count function returns the number of matches of the pattern in the input strings. For the data used in the previous section, the str_count function returns a vector of the number of the matches as shown below.

data <- c("123 Main St", "6175551234", "978-356-1234", "Work: 617-423-4567; Home: 508.555.3589; Cell: 555 777 3456")

phone <- "([2-9][0-9]{2})([- .]?)([0-9]{3})([- .])?([0-9]{4})"

str_count(data, phone)

# The str_count function can also be used for counting the number of sentences, the number of words, or the number of characters in the input string as shown below.

x <- "Hello, how are you? I am fine, thank you."

str_length(x)

str_count(x, boundary("sentence"))

str_count(x, boundary("word"))

str_count(x, boundary("character"))

# If the input is a vector of strings, the str_count function returns the number of matches in each input string as shown below.

y <- c("Hello, how are you? I am fine, thank you.", "Good bye!")

str_length(y)

str_count(y, boundary("sentence"))

str_count(y, boundary("word"))

str_count(y, boundary("character"))

######################
# Splitting of Strings
######################

# The str_split function splits the input string into parts over the specified pattern. Typically sentence, word, and character boundaries are useful for splitting the given string. The following examples show how two input strings are split at the sentence boundary. The first input string has two sentences, whereas the second input string has only one sentence. By default, the results are returned as a list of character vectors.

x <- c("Hello, how are you? I am fine, thank you.", "Good bye!")

str_split(x, boundary("sentence"))

str_split(x, boundary("sentence"), simplify = T)

# The input strings can be split at the word boundary as shown below.

str_split(x, boundary("word"))

# The number of pieces that an input string is split into can be limited by optionally providing a value for the n argument. In the following case, a maximum of 4 splits are allowed in each sentence at the word boundary.

str_split(x, boundary("word"), n = 4)

# The input strings can also be split at the character boundary as shown below. Each individual character will be a part of the vector of splits.

str_split(x, boundary("character"))

##################################
### Section #2: Data Wrangling ###
##################################




