# Module 3 Lecture Notes

#####################################
#### Section #1 - Types of Data #### 
#####################################

# The data that we analyze can be classified into two types:
# Qualitative data, associated with a property or a quality (e.g., gender, eye color, grade, rank, etc.) # Quantitative data, associated with a numeric measurement (e.g., temperature, age, weight, income, etc.)

# The qualitative data, also known as categorical data, can further be classified as:

# Nominal data, where there is no ranking among the distinct categories (e.g., male or female for gender, democrat, republican, or independent for party affiliation, etc.)

# Ordinal data, where there is an implicit ranking among the distinct categories (e.g., sergeant, lieutenant, captain, or chief for the police rank, A, B, C, D, or F for class grade, poor, good, or excellent for customer satisfaction, etc.)

# An example of nominal categorical data is the list of states as shown below. The state.abb dataset provided by R lists the state abbreviations in alphabetical order.

## Nominal Example:
state.abb

# The quantitative data, also known as numerical data, can further be classified as:
# Interval data, where the values are ordered and the difference in the values is meaningful (e.g., temperature in Fahrenheit. If the morning temperature is 60 and the afternoon temperature is 70, it is 10 degrees warmer. If the average temperatures in May and December are 90 and 45, respectively, we cannot infer that May is twice as warm as December). We can only add or subtract with interval data—we cannot multiply or divide. Ratio data, where the values are ordered and can be compared using addition, subtraction, multiplication, or division (e.g., age in years. We can compare twice as old, two years older, etc.)

# Example Datasets for R
# Some of the datasets are in the basic datasets package. Other datasets are in the UsingR package. For working with the UsingR datasets, the library is first loaded as follows.

## Load Package
# library(UsingR)

########################################
##### Section #2 - Univariate Data #####
########################################

# Univariate datasets deal with data contained in a single variable. Even if the dataset consists of the data for multiple variables, univariate analysis examines one variable at a time. The data can be categorical data or numerical data. Summary descriptions and visual representations of the data are presented in the following sections.

# Use the following commands to load the 'BushApproval' data set into memory. The following problems will use this data set. Feel free to explore the data and data types present before proceeding.
(data <- BushApproval)

(date <- BushApproval$date)

# What kinda of data is date?

#Answer: Quantitative because it can calculated/measured & Interval data because the data can only be added or subtracted & we know its numerical.

#########################################
##### Section #3 - Categorical Data #####
#########################################

# Tables are frequently used for summarizing the categorical data for non-visual representations. Given a vector of values, x , the function table(x) tabulates the frequencies for all the unique values in the data vector x . The function can be applied for both categorical data and numerical data.

(x <- c("yes", "no", "no", "yes", "no"))

table(x)



# The dataset central.park.cloud (from the UsingR package) contains the information about the type of day (clear, partly.cloudy, or cloudy) for Central Park, NY, during the month of May 2003. The dataset is shown below.

central.park.cloud

# The table function provides a more meaningful summary, showing the frequencies of the types of days.

table(central.park.cloud)

# The proportion of each of these categories with respect to the total size of the dataset can be calculated as follows.

table(central.park.cloud) / length(central.park.cloud)

# Which column represents categorical data? Show the R commands for the Bush Approval data set

(x <- data$who)
levels(x)

######################################################################
##### Section #3 - Categorical Data ##################################
##### Sub-Section: Graphical Representations of Categorical Data #####
######################################################################

# The frequencies of the various categories can be graphically represented using a barplot. By default, the bars are drawn vertically with the first data bar at the left. The names of the categories are used as the labels for the bars.

barplot(table(central.park.cloud), col = "cyan", ylim=c(0,12), xlab = "Type", ylab = "Frequency")

barplot(table(central.park.cloud), col = c("red", "green", "blue"), ylim = c(0,12), xlab = "Type", ylab = "Frequency")

# A barplot could be misleading if the ranges of the frequencies are not properly shown. The same data would produce the following chart if the y-axis were limited to the range 8 to 12.

# The barplot can be created with the bars shown horizontally; the option is specified as shown below.

barplot(table(central.park.cloud), col = "cyan", horiz = TRUE, xlim = c(0,12), las = 2, xlab = "Frequency")

barplot(table(central.park.cloud), col = c('red', 'green', 'blue'), horiz = TRUE, xlim = c(0,12), las = 2, xlab = 'Frequency')

# A pie chart of the data is useful for comparing the proportions of each of the categories.

pie(table(central.park.cloud), col=(c(0,60,120)))

pie(table(central.park.cloud), col=(c('red','blue','green')))

# The labels for the pie chart can be customized as shown below. The proportion of each category is computed and appended to the respective name.

(data <- table(central.park.cloud))
(slice.labels < names(data))
(slice.percents <- round(100 * data/sum(data)))
(slice.labels <- paste(slice.labels, slice.percents))
(slice.labels <- paste(slice.labels, "%", sep=""))

pie(data, labels = slice.labels,col=hcl(c(0, 60, 120)))

############################
#### Test Yourself 3.4 ####
############################

# Create a bar chart using the data from the 'who' column. Label the columns appropriately. Show the R commands
(data <- BushApproval)

(y <- data$who)

barchart(y, xlab = "Frequency", ylab = "who", horiz=TRUE)

(data <- BushApproval)

(y <- data$who)

barchart(y, xlab = "who", ylab = "Frequency", horiz = TRUE)

############################
#### Test Yourself 3.5 ####
############################

(Y <-table(data$who))

pie(Y)
 
########################################
##### Section #4 - Numerical Data #####
#######################################

# For the variables that hold numerical data, the common summaries of the variables are described using the measures of center and spread. The common measures of central tendency are the mean, the median, and the mode.

# Consider the following dataset showing the grades of 11 students in an exam. The data is already in the sorted order.

(x <- c(71,72,73,73,74,75,77,81,83,87,91))

# The mean of the above variable is computed as shown below.
mean(x)

# In scenarios where the ends of the data contain extremely low and extremely high values, the mean of the trimmed dataset can be computed as shown below. In the following case, 10% of the data is trimmed from both the ends when computing the mean for illustration only.
mean(x, trim=0.1)

# The median of the variable is computed as shown below.
median(x)

# The mode of the variable is computed indirectly as there is no direct function in R. The table function shows the frequencies of the unique values in the given data. The maximum value is the mode.
table(x)

(which(table(x) == max(table(x))))

# The value 73 occurs twice, which is the maximum occurrence. The second value shown by the which function is the index of the value in the tabular representation.
# The common measures of spread are the range, the variance, the standard deviation, and the interquartile range. The range of the variable is the difference between the maximum and the minimum value. The function, range, returns the values as a pair.
range(x)
diff(range(x))

# The variance and the standard deviation of the variable are computed as shown below.
var(x)

sd(x)

# The interquartile range represents the middle 50% of the data. This value is computed as the difference between the third quartile (75 percentile) and the first quartile (25 percentile). The function fivenum gives the five-number summary of the data (minimum, first quartile/lower hinge, median, third quartile/upper hinge, maximum). The summary function gives the mean in addition to the above five numbers.
fivenum(x)

summary(x)

quantile(x, c(0, 0.25, 0.5, 0.75, 1))

IQR(x)
# The above value is the difference between the third quartile, 82, and the first quartile, 73.

# The z-scores of the data show the number of standard deviations the value is from the mean of the data set. The above data has a mean value 77.91 and a standard deviation of 6.67. The scale function computes the z-scores of the given data.

scale(x)

# The z-scores of a given dataset have a mean of 0 and a standard deviation of 1.

# In the above example, which had an odd number of values, the fivenum and summary functions produced the same results. However, these two functions behave differently when computing the quartiles for even number of values as shown below.

(x <- c(71,72,73,73,74,75,77,81,83,87,90,91))
fivenum(x)

summary(x)

quantile(x, c(0,0.25, 0.5, 0.75, 1))

# The quartiles shown in the summary function correspond to the values directly computed using the quantile function. The interquartile range function also uses these values.

IQR(x)

############################
#### Test Yourself 3.6 ####
############################

# Assign the 'approval' column to a new variable. What is the mean approval? What is the median approval? What is the variance of the approval? Produce a summary using the summary() function. Show all R commands.

(approval <- data$approval)

mean(approval)
median(approval)
summary(approval)
var(approval)

######################################################################
##### Section #5 - Numerical Data ####################################
##### Sub-Section: Graphical Representations of Numerical Data #######
######################################################################

# The following dataset variable (central.park from the UsingR package) shows the minimum temperatures observed in Central Park (New York City) during May 2003.

central.park$MIN

# The summary function shows the various measures of the data.

summary(central.park$MIN)

# A barplot showing the daily minimum temperatures is plotted as shown below.
?attach()

attach(central.park)

barplot(MIN, names = 1:31, xlab = "Day", ylab = "Min Temp", col = "cyan", las = 2)

# The dotchart is sometimes used as a substitute for the barplot. The values of the variable are shown as dots horizontally over the range of the data.

dotchart(MIN, labels = 1:31, xlab = "Min Temp")

# The table function may also be used with the numeric data for finding the frequencies of the unique values in the data.
table(MIN)

# A barplot showing these frequencies is seen below. The heights of the bars show how many days in the month had that particular minimum temperature.

barplot(table(MIN), col = "cyan", ylim=c(0,6), xlab = "Min Temp", ylab = "# of Days")

############################
#### Test Yourself 3.7 ####
############################

# Produce a dot plot of the approvals. Show the R commands

(data <- BushApproval)
(approval <- data$approval)

dotchart(approval)

############################
#### Test Yourself 3.8 ####
############################

# Produce a barplot showing the frequency of the approvals. Show the R commands

barplot(table(approval), ylab = "Frequency", xlab = "Approval", ylim = c(0, 20))

####################
#### Stem Plots ####
####################

# The stem and leaf plot is useful for small datasets as it shows the values and the shape of the distribution compactly. The stem is the number on the left of the bar. The number on the right of the bar is the leaf.

(x <- c(72,73,71,73,74,75,77,81,83,87,91,92))

stem(x)

############################
#### Test Yourself 3.9 ####
############################

# Produce a stem plot of the approvals. The stem should be value in the tens place while the leaves represent the values in the ones place (e.g- 71 would be 7 | 1). Adjust the stem() function's scale and width arguments to get the desired plot. Show the R commands.

(data <- BushApproval)
(approval <- data$approval)

stem(approval, scale = 0.5)

#################################
#### Histograms and Boxplots ####
#################################

# The histogram shows the frequency of the data for a particular interval, whereas the barplot is used for a category. The alltime.movies dataset (from the UsingR package) shows the gross receipts (in millions) for the top 79 movies as of the year 2003. The data is already sorted in descending order.

head(alltime.movies, n = 2)

# The histogram for the data is shown below.
attach(alltime.movies)

hist(Gross, col=hcl(0), ylim=c(0,35))

# The above plot shows that 31 movies had gross receipts of less than 200 million dollars and one movie greater than 600 million dollars. The intervals (also known as bins or buckets) for the histogram bars can be examined by assigning to a variable as shown below. The breaks variable of the histogram shows the ranges for each interval. The counts variable shows the number of values that lie within each of these intervals. Note that the length of counts is one less than the length of breaks.
(x <- hist(Gross))

names(x)

x$breaks

x$counts

# The sequence of breaks can be explicitly specified for the histogram. Another option is to specify the number of breaks for the histogram. Both these options are shown below.

(x1 <- hist(Gross, breaks = seq(170,620,25), col = hcl(0), ylim = c(0,35)))

(x2 <- hist(Gross, breaks = 5, col = hcl(0), ylim = c(0,35)))

# The shape of the histogram differs depending upon how the intervals are established.

# The breaks and the counts for the above two options are as follows.

x1$breaks

x1$counts

x2$breaks

x2$counts

# A boxplot (also known as box and whisker plot) is used to display the five-number summary of the data and allows the visual inspection of the center of the data, the spread of the data, and the skew of the data. The boxplot function, by default, shows the plot vertically. In the following example, the boxplot is drawn horizontally.

(x <- c(71,72,73,74,75,77,81,83,87,91,92))
boxplot(x, horizontal = TRUE)


# If there are no outliers in the data, the whiskers at the ends show the minimum and maximum values of the data. The left end of the box shows the lower hinge (or the first quartile) while the right end of the box shows the upper hinge (or the third quartile). The box is essentially the middle 50% of the data, the interquartile range. The thick line within the box shows the median of the data. The lower 50% of the data occurs to the left of the median, while the upper 50% of the data occurs to the right of the median. Similarly, the lower 25% of the data lies between the left whisker and the left edge of the box, while the upper 25% of the data lies between the right edge of the box and the right whisker.

# The five-number summary of the data is shown below.
fivenum(x)

# The default labels for the x-axis can be suppressed and labeled with the five-number summary values as shown below.

boxplot(x, horizontal = TRUE, xaxt = "n")
axis(side = 1, at = fivenum(x), labels = TRUE)

# If there are outliers in the data, the boxplot is modified to show the outliers. Any data that is greater than (3rd quartile + 1.5 ! IQR) or less than (1st quartile– 1.5 ! IQR) is considered an outlier and is plotted using the circle dots as shown below. If there are outliers, the whiskers at those ends mark the data point that doesn’t lie in the outlier range.

# The following data has two outliers on the lower end of the data.

(y <- c(35, 40,50,65,72,73,73,74,75,81,83,87,92))
boxplot(y, horizontal = TRUE, xaxt = "n")
axis(side = 1, at = fivenum(y), labels = TRUE)

## The lower and upper ends of the outlier ranges can be calculated as follows.

(f <- fivenum(y))

c(f[2] - 1.5*(f[4] - f[2]), f[4] + 1.5*(f[4] - f[2]))

# For the above dataset, any values that are less than 41 and greater than 105 are considered outliers. So, the values 35 and 40 are outliers. The whisker at the left is drawn at the next value 50.

# The following data has two outliers on the lower end and one outlier on the upper end of the data.

(z <- c(35, 40,55, 65,66,70,72,72,73,73,74,74,79,90))
boxplot(z, horizontal = TRUE, xaxt = "n")
axis(side = 1, at = fivenum(z), labels = TRUE, las=2)

# The lower and upper ends of the outlier ranges for the above data can be calculated as follows.

(f <- fivenum(z))

c(f[2] - 1.5*(f[4] - f[2]), f[4] + 1.5*(f[4] - f[2]))

# Hence, the values 35, 40, and 90 are marked as outliers. The whisker at the left is shown for the input value 55 whereas the whisker on the right corresponds to the input value 79.

# The boxplot for the gross receipts of the movies dataset is shown below.

attach(alltime.movies)

boxplot(Gross, col=hcl(0), xlab = "Gross Sales", horizontal = TRUE)

# The five-number summary values along with the text labels can be added to the plot as shown below.

boxplot(Gross, col=hcl(0), xaxt = "n", xlab = "Gross Sales", horizontal = TRUE)

axis(side = 1, at = fivenum(Gross), labels = TRUE, las=2)

text(fivenum(Gross), rep(1.2,5), srt = 90, adj = 0, labels = c("Min", "Lower Hinge", "Median", "Upper Hinge", "Max"))

# The boxplot shows that there are five outlier values at the upper end of the data. The titles of these movies and their gross receipts can be explicitly calculated as shown below.
(f <- fivenum(Gross))

(titles <- rownames(alltime.movies))

titles[Gross > f[4] + 1.5*(f[4] - f[2])]

Gross[Gross > f[4] + 1.5*(f[4] - f[2])]

############################
#### Test Yourself 3.10 ####
############################

# Produce a boxplot of the approvals. Label the plot at the five number summary positions. Show the R commands.

(data <- BushApproval)
(approval <- data$approval)

boxplot(approval, yaxt='n')
axis(side=2, at=fivenum(approval), labels=TRUE)

############################
#### Test Yourself 3.11 ####
############################

# Produce a histogram of the approvals. Make sure the range you select is appropriate and encompasses all approval values. Try 3 different bucket sizes. Show the R commands.

(data <- BushApproval)
(approval <- data$approval)

hist(approval, breaks=5)
hist(approval, breaks=10)
hist(approval, breaks=20)

############################
#### Test Yourself 3.12 ####
############################

# Add two values, 8 and 99 to the vector of approvals. Produce a boxplot. Are either of the new data points outliers? Show the R commands.

(data <- BushApproval)
(approval <- data$approval)

(x <- c(approval, 8, 99))

boxplot(approval)

# Yes, the two new data points are both outliers

########################################
##### Section #5 - Bivariate Data #####
########################################

# Bivariate datasets deal with data contained in two variables. Depending on the given data, the two variables may be related or unrelated. If the given data has the test scores of the students from two different sections taking the same test, the pairs of data are unrelated. If the same section of students takes two different tests, the data is related. In addition to summarizing data as categorical or numeric, the relationship between the data is also explored.

# Contingency (two-way) tables are frequently used to summarize bivariate categorical data. For each possible pair of values for the two variables, the contingency table provides the number of occurrences for that pair. Relationships between the two variables can be examined by comparing the rows/columns of the contingency table.

# If the data for the two categorical variables is given in the unsummarized form (the actual values), the contingency table is created using the R function table(x,y), where x and y are the two data vectors representing the two variables.

# The grades dataset (from the UsingR package) is used in this example. The dataset provides the grades of 122 students for the current class (grade) and their previous class (prev). The first six rows of the dataset are shown below.

head(grades)

# The contingency table between the prev and grade variables is computed using the table function. The function can be called directly on the dataset, table(grades), or explicitly by specifying the two variables as shown below.

attach(grades)

table(prev, grade)

# The above table shows that the current grades relate to the previous grades. Fifteen students who got A in the previous class also got A in the current class. Similarly, eleven students who got F in the previous class also got F in the current class. The lower left triangle shows the students who improved when the previous grade is compared to the current grade. The upper right triangle shows the number of students whose performance declined between the previous class and the current one.

##########################################
#### Two-way Tables - Summarized Data ####
##########################################

# If the raw data comparing two variables is available in summarized form, the data can be entered into R in various ways. The following table shows the results of a survey of 82 vehicles looking at seat belt use by parents and their children.

# The data can be entered using the rbind function, where each argument is a vector representing the corresponding row of the table.

(x <- rbind(c(56,8), c(2,16)))

# The data can also be entered using the cbind function, where each argument is a vector representing the corresponding column of the table.

(x <- cbind(c(56,2), c(8,16)))

# The matrix function can also be used by providing all the values as a single vector in the column-major order (default) and specifying either the number of rows or number of columns.

(x <- matrix(c(56,2,8,16), nrow=2))

# If the values are desired in the row-major order, the byrow option is specified as TRUE.

(x <- matrix(c(56,8,2,16), nrow=2, byrow = TRUE))

# Once the table is created, names may optionally be assigned to the rows and columns of the table as follows.
rownames(x) <- c("buckled", "unbuckled")
colnames(x) <- c("buckled", "unbuckled")
x

row1 <- c(56,8)
names(row1) <- c("buckled" ,"unbuckled")

row2 <- c(2,16)

(x <- rbind(buckled = row1, unbuckled = row2))

# The names for the variables can be specified using dimnames() as follows.

(tmp <- c("buckled", "unbuckled"))
(dimnames(x) <- list(parent=tmp, child=tmp))
x

############################
#### Test Yourself 3.13 ####
############################

# Consider the following data set representing a clinical trial on 10 patients. Each row represents a patient and the first column indicates their disease level before treatment while the second column represents the disease level after treatment. It should be noted that the disease level is a categorical variables and can take on the following values: "mild", "moderate", "severe", "terminal"

# Use whatever R commands needed to produce a two-way table representing the unsummarized data in the table above.

(pre <- c("mild", "moderate", "mild", "moderate", "severe", "severe", "terminal", "terminal", "severe", "moderate"))

(post <- c("mild", "mild", "mild", "mild", "severe", "moderate", "severe", "terminal", "mild", "moderate"))

table(pre,post)

# Values along the diagonal indicate the number of patients who say no changes in their disease status after treatment. Numbers in the upper diagonal represent patients whose status worsened, while those in the lower diagonal represent patients whose status improved.

############################
#### Test Yourself 3.14 ####
############################

#Reproduce the summarized table from the previous problem using the matrix() command. Name the rows and columns accordingly. Show the R commands.


data <- matrix(c(2, 0, 0, 0, 2, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1), nrow=4, byrow=TRUE)
levels <- c('mild',  'moderate',  'severe',  'terminal')
dimnames(data) <- list(before.treatment=levels, after.treatment=levels)
data

##################################################
#### Marginal Distributions of Two-way Tables ####
##################################################

# The distribution of each variable separately is the marginal distribution of that variable. In a two-way table, adding the rows or the columns gives the marginal distribution of the corresponding variable. The apply sum or the margin.table function can be used for this purpose.

# For the seat belt dataset, the marginal distribution for the parent (rows in the table) is calculated as follows. The argument value 1 identifies the rows while the value 2 identifies the columns.

x

apply(x, 1, sum) # row wise

margin.table(x, 1) # row wise

# Similarly, the marginal distribution for the child variable (columns in the table) is computed as follows.

apply(x, 2, sum) # column wise

margin.table(x, 2) # column wise

# If neither the row nor the column is specified, the function returns the sum of all the values in the table.

margin.table(x)

# The addmargins function extends the two-way table by adding the marginal distributions as shown below.

addmargins(x)

addmargins(x, 1)

addmargins(x, 2)

# Similarly, for the grades dataset shown below, the marginal distributions of the previous grade (prev) and current grade (grade) variables can be computed.

(y <- table(prev, grade))

(margin.table(y, 1))

(margin.table(y, 2))

# From the above, 28 students had an A grade in the previous class while 21 students got an A grade in the current class. The number of F grades remained the same.

margin.table(y)

addmargins(y)

addmargins(y,1)

addmargins(y,2)

############################
#### Test Yourself 3.15 ####
############################

# Using the table generated in the previous problem, produce a marginal table by using the apply() and sum() functions. Repeat the task using the margin.table() function. Now add the margins to the original table. Show the R commands.

apply(y, 1, sum)

apply(y, 2, sum)

margin.table(y, 1)

margin.table(y, 2)

(data.with.margins <- addmargins(y))

#####################################################
#### Conditional Distributions of Two-way Tables ####
#####################################################

# When comparing the rows (or columns) of the two-way table, having the values as proportions or percentages is more effective. The prop.table function computes the percentages with respect to the sum of the corresponding row (or column). With the argument value 1, the values of the rows add to 1 (100%). With the argument value 2, the values of the columns add to 1 (100%).

options(digits = 2)

addmargins(x)

# From the above table, 88% of the time children wear seat belts when their parents do. If the parent is not wearing a seat belt, 11% of the time the child wore the seat belt, while 89% of the time the child did not.

# Similarly, the proportions along the columns are shown below.

# Prob of being MALE/FEMALE conditional of being a Admitted/Rejected
prop.table(x,1)

# Prob of being Admitted/Rejected conditional of being Male/Female
prop.table(x,2)


# If the row or column is not specified, the prop.table function computes the relative percentages with respect to the entire table.

prop.table(x)

# The proportions for the grades dataset along the rows are shown below. For each row, the percentages show the effect of the previous grade on the current grade.

prop.table(y,1)

# The proportions for the grades dataset along the columns are shown below. For each column, the percentages show the effect of the current grade on the previous grade.

prop.table(y,2)

# The options function was used to set the number of digits in the decimal part for display purpose.
options(digits=1)

############################
#### Test Yourself 3.16 ####
############################

# Using the table generated in the previous problem, use prop.table() to show the table values as proportions of the marginal sums, as well as the total sum. Show the R commands.

prop.table(y, 1)
prop.table(y, 2)
prop.table(y)

###################################################
#### Graphical Summarization of Two-way Tables ####
###################################################

# The mosaic plot is one option for creating a graphical representation of the contingency table. The counts in the table are represented by rectangles. The mosaic plot of the seat belt data can be plotted in R as shown below
x

mosaicplot(x, color=c("red", "blue"))

# Similarly, the mosaic plot of the grade data is shown below.

mosaicplot(table(grades), color="cyan")

# The bar plot can also be used for the graphical presentation of the two-way data. The first argument is the two-way table. The first variable of the table is used for the categories of the bar plot. The bars for each level are stacked by default and the heights show the proportions of the second variable. In the following example, the variable x stores the seat belt dataset.

barplot(x, xlab = "Parent", main = "Child Seat-Belt Usage", ylim=c(0,60), col=c("red", "blue"))

# If the bars for the second variable are to be plotted side by side, the option beside=TRUE is specified. A legend can also be added to the plot as shown.

barplot(x, xlab = "Parent", main = "Child Seat-Belt Usage", beside = TRUE, legend.text = TRUE, ylim=c(0,60), col=c("red", "blue"))

# The above plots show the distribution of the child variable. However, if the parent distribution is desired, the table is first transposed and then the plot is done as shown below.

t(x)

barplot(t(x), xlab = "Child", beside = TRUE, legend.text = TRUE, main = "Parent Seat-Belt Usage", ylim=c(0,60), col=c("red", "blue"))

# Similarly, the bar plot for the grades dataset is shown below. The colors for the nine categories of grades can be explicitly specified, or the rainbow function can be used to create a vector of the required number of colors.

barplot(table(grades), xlab = "Prev Grade", beside = TRUE, legend.text = TRUE, main = "Current Grade", border=FALSE, args.legend = list(x = "center"), ylim=c(0,20), col = rainbow(9))

############################
#### Test Yourself 3.17 ####
############################

# Before continuing, let's replace our table with some different values. Replace the contents of the table produced in the previous problems with the values seen below:

# You may do this however you like but a recommendation is to assign the rows or columns of the matrix to these new values so as to maintain the dimension names and labels of your data. Show the R commands.

(data[1, ] <- c(10, 1, 0, 0))
(data[2, ] <- c(6, 9, 20, 0))
(data[3, ] <- c(1, 3, 5, 1))
(data[4, ] <- c(0, 1, 8, 4))

############################
#### Test Yourself 3.18 ####
############################

# Now that we have our new table, produce a mosaic plot of the table, use 4 different colors. Show the R commands.

mosaicplot(data, color = c("green", "yellow", "red", "blue"))

############################
#### Test Yourself 3.19 ####
############################

# Show a barplot of the data where the x-axis indicates the patient's disease status before treatment. You may use a stacked barplot or set beside=TRUE. In any case, you must label your axes and include a legend. Show the R commands.

barplot(data, xlab="Status.After.Treatment", beside = TRUE, main = "Patient disease status before/after treatment", col = c('green', 'yellow', 'red', 'black'), legend.text=TRUE)

# Load the iris data set using data('iris'). Produce a scatter plot of the Sepal Length vs. the Sepal Width. Label the axes. Show the R commands.

data('iris')

plot(iris$Sepal.Length, iris$Sepal.Width)

######################################################
##### Section #6 - Relationships in Numeric Data #####
######################################################

# The two-way table allows us to investigate the relationship between categorical variables. In this section, the relationship between numerical variables is explored. The bivariate data of two numeric variables X and Y has a natural pairing, (x1 , y1 ), (x2 , y2 ), ... (xn , yn ). In some cases, the variables are related and in other cases, no relation exists between them. The scatterplot is one option to explore the relation between the two numeric variables. The home dataset (from the UsingR package) shows the old and the new prices of 15 homes from Maplewood, NJ. The home prices were assessed first in 1970 and then again in 2000, after 30 years. The first two rows of the dataset are shown below.
options(digits = 3)
help(home)

head(home, n=2)

# A scatterplot is drawn using the plot function. The old home prices are plotted against the new home prices.

attach(home)

plot(old, new)

# With a few exceptions, the data falls along a straight line showing a linear increase in the home prices. The five- number summary of the old prices and the new prices are shown below. The ratio of the two shows that some houses doubled in value, while others increased to six times the original value. On the average, the prices increased by four times.

summary(old)

summary(new)

summary(new/old)

# The next example shows the Dow Jones dataset and the maximum daily temperature in New York City for the month of May 2003.

help(maydow)

head(maydow, n = 2)

attach(maydow)

plot(max.temp, DJA)

# The next dataset (kid.weights) contains the weight and height measurement of 250 children. First, we will plot the height versus the weight separately for the boys and girls.

data(kid.weights)

attach(kid.weights)

plot(m$height, m$height, ylim=c(0,160))
plot(f$height, f$height, ylim=c(0,160))

(m <- subset(kid.weights, gender == "M"))
(f <- subset(kid.weights, gender == "F"))

##########################################
##### Section #7 - Multivariate Date #####
##########################################

# Multivariate datasets have data populated with more than two variables. The data can either be in the summarized form or in the original form. For categorical data, the table function may be used to summarize the data given in the original form. But, the table function shows only the relationship between two variables at once. For examining three or more variables, more than one table is used to show the relationships.

# The student.expenses dataset (from the UsingR package) shows the survey results for ten students asked whether they incurred any expenses in the specified five categories. The categories and the first two rows of the data are shown below.

names(student.expenses)

head(student.expenses, n =2)

# Examining the relationship between two variables using the table function is straightforward. The following code shows the relationship between having cable TV and cable modem.

attach(student.expenses)

table(cable.tv, cable.modem)
cable.tv
# Similarly, the relationship between having cable TV and car is shown below.

table(cable.tv, car)
car

# Three-way or (n-way) contingency tables show the relationships among three (or n) variables using multiple two-way tables. The table function is invoked with the desired variables. The first two variables are fixed in the table output while the number of values for the extra variables determines the number of tables produced.

# In the following code, the effect of having a car is investigated with respect to the cable TV and the cable modem. Since the car variable has two values, two tables are shown one with the car variable equal to N and the other with the car variable equal to Y.

table(cable.tv, cable.modem, car)

# The above output can be flattened using the ftable function. The flatten table function is invoked on the table by specifying the desired columns using the col.vars argument.

ftable(table(cable.tv, cable.modem, car), col.vars = c("car", "cable.modem"))

# Similarly, the flattened table with four variables is shown below.

ftable(table(cable.tv, cable.modem, cell.phone, car), col.vars = c("car", "cable.modem", "cell.phone"))

cable.tv

############################
#### Test Yourself 3.21 ####
############################

# Load the motor trends data set using data(‘mtcars’). How many variables does each entry contain?

data("mtcars")

mtcars
## 11 variables
ncol(mtcars)

############################
#### Test Yourself 3.22 ####
############################

# Using the mtcars data set, slice the data frame such that the resulting data frame contains only the columns 'cyl', 'disp', 'hp', 'gear'. Make sure the resulting data frame has the same row names as that of mtcars. Using mtcars and the table() function to produce two-way tables of the 'cyl' vs the other three variables above. Show all R commands.

attach(mtcars)

(data <- cbind(cyl, disp, hp, gear))
(rownames(data) <- rownames(mtcars))
table(cyl, disp)
table(cyl, hp)
table(cyl, gear)

############################################
##### Section #8 - Independent Samples #####
############################################

# In the student.expenses dataset, the variables are dependent for the particular student. However, if the dataset has several variables of the same type, the data can be compared using their means and spreads through box plots. The ewr dataset (from the UsingR package) has the monthly average taxi in and taxi out times of 8 different airlines at the Newark (EWR) airport during the months from January 1999 to November 2000.

names(ewr)

head(ewr, n = 2)

tail(ewr, n = 2)

# A box plot of the average times of the given airlines shows the differences in the performances of the airlines. The data for both the taxi in and taxi out times is plotted as shown below.

attach(ewr)

boxplot(AA,CO,DL,HP,NW,TW,UA,US, col = rainbow(8))

boxplot(ewr[3:10], col = rainbow(8)) # Get the 3rd-10th col values for names

# From the above figure, the second airline has the worst performance. The fourth airline has the largest median.

# The given data has both the taxi in and taxi out times. The taxi in time is relatively smaller than the taxi out time. Investigating these two times separately provides more insight into the data. Filtering the data based on the inorout variable, the following plot shows the taxi in times and taxi out times of the given airlines side by side.

boxplot(ewr[inorout == "in", 3:10], main = "Taxi in", col = rainbow(8))

boxplot(ewr[inorout == "out", 3:10], main = "Taxi out", col = rainbow(8))

############################
#### Test Yourself 3.23 ####
############################

# Using the iris data set, produce boxplots of the sepal width, sepal length, petal width, and petal length. Slice the iris data set so it contains only flowers of the 'virginica' species. Produce boxplots of the virginica sepal width, sepal length, petal width, and petal length. Show the R commands.

data('iris')
attach(iris)

boxplot(Sepal.Width, Sepal.Length, Petal.Width, Petal.Length)

data <- iris[Species == 'virginica', ]

boxplot(data$Sepal.Width, data$Sepal.Length, data$Petal.Width, data$Petal.Length)

#################################################
#### Relationship Between Pairs of Variables ####
#################################################

# The scatterplot matrix shows the pair-wise relationships between the given variables using a scatter plot for each pair. For the airline ewr dataset, consider the first four airlines (columns 3 to 6).

head(ewr[3:6], n = 2)

# The taxi in times of these airlines are plotted pair-wise as shown below.

pairs(ewr[inorout == "in", 3:6], main = "Taxi in", pch=16)

# Similarly, the pair-wise comparison of the taxi out times of the first four airlines is shown below.

pairs(ewr[inorout == "out", 3:6], main = "Taxi out", pch=16)

############################
#### Test Yourself 3.24 ####
############################

# Using the mtcars data set, produce a scatter plot of the the 'mpg' vs the 'hp'. Briefly describe any trends you see. Show the R commands.

attach(mtcars)

plot(mpg, hp)

# In general, the mpg and hp are inversely correlated. As hp increases, mpg tends to decrease.

############################
#### Test Yourself 3.25 ####
############################

# Use the pairs() function to plot the Sepal Width, Length, Petal Width, Length, of the virginica species. Exclude the 'Species' column. Show the R commands.

# We already created a filter for virginica species above. We can reuse that and slice it accordingly

pairs(data[ , 1:4])

########################################
##### Section #9 - Summarized Data #####
########################################

# The UCBAdmissions dataset contains the summarized data of admissions and rejections of male and female applicants who applied to the top six graduate school departments at UC Berkeley in the year 1973. The data is in a 2×2×6 table.

# The dimension names are Admit, Gender, and Dept. The categorical values for these dimensions are shown below.

dimnames(UCBAdmissions)

# The data contains the summarized information about 4526 applicants. The two-way tables for the six departments are shown below.
UCBAdmissions

# The number and proportion of the total male and female applications (the second dimension) can be computed as follows.

margin.table(UCBAdmissions, 2)

prop.table(margin.table(UCBAdmissions, 2))

# Similarly, the number and proportion of the total admitted and rejected applications (the dimension 1) are as follows.

margin.table(UCBAdmissions, 1)

prop.table(margin.table(UCBAdmissions, 1))

# The marginal distribution of the data over the first two dimensions (adding over all the departments) is shown below.

margin.table(UCBAdmissions, c(1,2))

# The proportional distribution of the Admit and Gender dimensions over the margin for rows (margin = 1) is:

(x <- margin.table(UCBAdmissions, c(1,2)))
prop.table(x, margin = 1)

# The above results show that among the admitted applicants, 69% are male while 32% are female. Among the rejected applicants, 54% are male while 46% are female.

# The proportional distribution of the Admit and Gender dimensions over the margin for columns (margin = 2) is:

prop.table(x, margin=2)

# The above results show that the males have a 45% chance of getting admitted while the females have only a 30% chance of getting admitted.

# A mosaic plot of the above marginal distribution for Admit versus Gender is shown below.

mosaicplot(x, color=c("green", "red"))

# A bar plot showing the information for each department is computed as shown below. For the male and the female applicants, the number of accepted and rejected applicants is shown for each department. The first two departments are drawn separately to show the legend


par(mfrow=c(3,2))
for (i in 1:2)
barplot(UCBAdmissions[,,i],
col = c("green", "red"), legend.text=TRUE,
main=paste("Dept",LETTERS[i],sep=" "))

for (i in 3:6)
barplot(UCBAdmissions[,,i],
col = c("green", "red"),
main=paste("Dept",LETTERS[i],sep=" "))




















